package SkillCategory.DynamicProgramming;

/**
 * @author Yiwen Xie
 * @description 给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。
 * 其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？
 * example:
 * N = 3, W = 4
 * wt = [2, 1, 3]
 * val = [4, 2, 3]
 * 算法返回 6，选择前两件物品装进背包，总重量 3 小于 W，可以获得最大价值 6。
 * 这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。这就是 0-1 背包这个名词的来历。
 * <p>
 * 第一步要明确两点，「状态」和「选择」。
 * 状态:「背包的容量」和「可选择的物品」。
 * 选择：「装进背包」或者「不装进背包」
 * 第二步要明确 dp 数组的定义。
 * dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。
 * 根据这个定义，我们想求的最终答案就是 dp[N][W]。
 * 第三步，根据「选择」，思考状态转移的逻辑。
 * dp[i][w] 表示：对于前 i 个物品（从 1 开始计数），当前背包的容量为 w 时，这种情况下可以装下的最大价值是 dp[i][w]。
 * 如果你没有把这第 i 个物品装入背包，那么很显然，最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。
 * 如果你把这第 i 个物品装入了背包，那么 dp[i][w] 应该等于 val[i-1] + dp[i-1][w - wt[i-1]]。
 * 首先，由于数组索引从 0 开始，而我们定义中的 i 是从 1 开始计数的，所以 val[i-1] 和 wt[i-1] 表示第 i 个物品的价值和重量。
 * 你如果选择将第 i 个物品装进背包，那么第 i 个物品的价值 val[i-1] 肯定就到手了，接下来你就要在剩余容量 w - wt[i-1] 的限制下，在前 i - 1 个物品中挑选，求最大价值，即 dp[i-1][w - wt[i-1]]。
 * dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
 * @date 2023/12/9 9:39
 */
public class BackpackProblemTemplate {
    /**
     * 拉布拉多
     *
     * @param W
     * @param N
     * @param wt
     * @param val
     * @return
     */
    int knapsack(int W, int N, int[] wt, int[] val) {
        assert N == wt.length;
        // dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。
        int[][] dp = new int[N + 1][W + 1];
        // base case 就是 dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。
        for (int i = 1; i <= N; i++) {
            for (int w = 1; w <= W; w++) {
                // 剩余容量不够了
                if (w - wt[i - 1] < 0) {
                    // 这种情况下只能选择不装入背包
                    dp[i][w] = dp[i - 1][w];
                } else {
                    // 装入或者不装入背包，择优
                    dp[i][w] = Math.max(
                            // 把这第 i 个物品装入了背包
                            // dp[i][w] 应该等于 第 i 个物品的价值 val[i-1] + 剩余容量 w - wt[i-1]
                            dp[i - 1][w - wt[i - 1]] + val[i - 1],
                            // 没有把这第 i 个物品装入背包
                            // 最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。
                            dp[i - 1][w]
                    );
                }
            }
        }

        return dp[N][W];
    }

    /**
     * 代码随想录：二维DP
     *
     * @param W   可装载重量为 W
     * @param N   N个物品
     * @param wt  第 i 个物品的重量为 wt[i]
     * @param val 第 i 个物品的价值为 val[i]
     * @return
     */
    int backpack(int W, int N, int[] wt, int[] val) {
        // dp[i][j] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。
        int[][] dp = new int[N + 1][W + 1];

        /*
         * base case
         *  背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。
            状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。
            dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。
            需要倒叙遍历，正序遍历不行，dp[0][j]表示容量为j的背包存放物品0时候的最大价值，物品0的价值就是15，
            因为题目中说了【每个物品只有一个！】 所以dp[0][j]如果不是初始值的话，就应该都是物品0的价值，也就是15。
            但如果一旦正序遍历了，那么物品0就会被重复加入多次！
            所以一定要倒叙遍历，保证物品0只被放入一次！这一点对01背包很重要，后面在讲解滚动数组的时候，还会用到倒叙遍历来保证物品使用一次！
         */
        for (int j = W; j >= wt[0]; j--) {
            dp[0][j] = dp[0][j - wt[0]] + val[0]; // 初始化i为0时候的情况
        }

        /*
         * dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？
         * dp[i][j]在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，因为0就是最小的了，不会影响取最大价值的结果。
         * 如果题目给的价值有负数，那么非0下标就要初始化为负无穷了。例如：一个物品的价值是-2，但对应的位置依然初始化为0，那么取最大值的时候，就会取0而不是-2了，所以要初始化为负无穷。
         * 这样才能让dp数组在递归公式的过程中取最大的价值，而不是被初始值覆盖了。
         */

        for (int i = 1; i <= N; i++) {
            for (int w = 1; w <= W; w++) {
                // 剩余容量不够了
                if (w - wt[i - 1] < 0) {
                    // 这种情况下只能选择不装入背包
                    dp[i][w] = dp[i - 1][w];
                } else {
                    // 装入或者不装入背包，择优
                    dp[i][w] = Math.max(
                            // 把这第 i 个物品装入了背包
                            // dp[i][w] 应该等于 第 i 个物品的价值 val[i-1] + 剩余容量 w - wt[i-1]
                            dp[i - 1][w - wt[i - 1]] + val[i - 1],
                            // 没有把这第 i 个物品装入背包
                            // 最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。
                            dp[i - 1][w]
                    );
                }
            }
        }
        return dp[N][W];
    }

    /**
     * 代码随想录：一维DP，滚动数组
     *
     * @param W   we
     * @param N
     * @param wt  背包
     * @param val
     * @return
     */
    int backpack2(int W, int N, int[] wt, int[] val) {
        // dp[j] 的定义如下：为 容量为j的背包所背的最大价值
        int[] dp = new int[W + 1];
        // base case dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。
        // dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。
        // 这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。
        dp[0] = 0;
        // 如果使用一维dp数组，物品遍历的for循环放在外层，
        // 遍历背包的for循环放在内层，且内层for循环倒叙遍历！
        // 先遍历物品嵌套遍历背包
        for (int i = 0; i < N; i++) {
            // 二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。
            // 倒叙遍历是为了保证物品i只被放入一次！
            // 为什么二维dp数组历的时候不用倒叙呢？
            //因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！
            for (int j = W; j >= wt[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - wt[i]] + val[i]);
            }
        }
        return dp[W];
    }

}
